# DDD、DSL 和 DCI

## DDD
   领域模型驱动， 概念最早提出于 2004 年，作为一种软件开发的指导思想DDD 对软件开发带来了诸多可能与方向。

* 首先，最大好处就是所有参与者围绕一个统一一致的领域模型工作，传统的分析模型和设计模型不再割裂，不管是做设计、做分析还是写代码、写文档，脑海中所构建的画面都是一致的。

* 第二，DDD 是一个软件开发过程，它显式地把领域和设计放到了软件开发的核心，软件人员和业务人员被受到同样的重视，他们合作来构建领域模型，使得软件的交付质量更高且维护成本更低；

* 第三，DDD 提出的分层架构，有效分离了业务复杂度和技术复杂度，凸显了领域模型，使得领域层的代码和领域模型保持高度一致；

* 第四，统一语言非常重要，每个概念在各自的上下文中是清晰的无歧义的，同时要控制领域模型的复杂度，于是 DDD 在战略上提出了分离子域（问题域空间）和拆分 BC（解决方案空间）的模式，BC 间通过 Context Mapping 来集成；

* 第五，DDD 在战术层面提出了很多模式（聚合，实体，值对象，服务，工厂，仓储），对领域模型中的元素进行了分类，并给出了每类元素在领域模型中的职责和特征，降低了领域模型的构建成本。

## DSL
> Domain-Specific Language 领域特定语言

 可以看作是在领域模型之上的一层外壳，可以显著增强领域模型的能力。它的价值主要有两个，一是提升了开发人员的生产力，二是增进了开发人员与领域专家的沟通。

 DDD 和 DSL 的融合有三点：

* 面向领域；

* 模型的组装方式；

* 分层架构演进。

## DCI
> Data，Context， Interactive

重点是关注数据的不同场景的交互行为，是面向对象系统状态和行为的一种范式设计；DCI 在许多方面是许多过去范式的统一，多年来这些模式已经成为面向对象编程的辅助工具。

DCI 助力 DDD 战术设计：

1. 显式地对 ROLE 建模，解决了贫血模型与充血模型之争；

2. 一个聚合可以支持哪些 ROLE，一个 ROLE 可以由哪些聚合扮演，一个场景下哪些聚合要扮演哪些角色；

3. 当 Aggregate 内部实体行为比较多时可以嵌套使用 DCI 来拆分和组合；

DCI 助力 DDD 代码落地：

1. 对象就是 Data，Client 为 Context，对象在 Client 中的行为就是 ROLE。

2. 根据正交设计原则得到小类（素材库），依赖注入来组合素材，不管是行为类还是数据类，都按 Role 的方式来组合，对像仅仅组合 Role 并注入依赖；

3. 小类大对象：类作为一种模块化手段，遵循高内聚，低耦合，让软件易于应对变化；对象作为一种领域对象的的直接映射，解决了过多的类带来的可理解性问题，让领域可以指导设计，设计真正反映领域；领域对象需要真正意义上的生命周期管理。

## 开发团队真的需要 DDD

DDD 思想贯穿了整个软件开发的生命周期，包括对需求的分析、建模、架构、设计，和最终的代码实现，甚至对代码的测试与重构。代码是业务的核心资产，不管是否特性团队，开发团队肯定是代码的编写者和守护者。

对于开发团队而言，需要关注以下几点：

* 首先是统一语言，让团队成员可以做到无障碍的沟通，不管是什么角色都能基于同样的画面进行讨论；

* 其次是团队中各个角色都围绕领域模型开展工作；

* 第三是代码物理设计容易标准化，比如说在分层设计时，基础设施层怎么设计，应用层怎么设计，DTO 应该放在哪儿，领域层中各个建模元素如何组织？

更进一步，在分层架构里，应用层更加关注横切面的东西，比如说要上报一个告警，要给用户发送一个 Email，这些最好都集中放到应用层里面。但触发是在领域层发生的，应用层怎么知道？通过领域事件来实现依赖反转，即应用层订阅领域事件，领域层发布领域事件。

## DDD 与微服务

微服务架构从提出以来一直没有很好的理论支撑如何合理地划分服务边界，人们常常为服务要划分多大而争吵不休。而 DDD 被发现恰好可以弥补微服务的营养不良：
* （1）服务最大不要大过一个 BC(Bounded Context，限界上下文)，否则服务内可能会存在有歧义的领域概念；
* （2）服务最小不要小过一个聚合，否则会引入分布式事务的复杂度；
* （3）服务间最好通过 Domain Event 来进行交互，这样可以让服务保持松耦合。微服务和 DDD 的结合，让微服务架构看起来似乎更加稳健了。